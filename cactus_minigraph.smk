#############################################################################
# Pipeline for running cactus-minigraph for pangenome creation
#############################################################################

import sys
import os
import re
import logging
import subprocess

import lib.cactuslib as cactuslib
import lib.treelib as treelib

#############################################################################
# System setup

DRY_RUN = False;
if any([arg in sys.argv for arg in ["--dry-run", "--dryrun", "-n"]]):
    DRY_RUN = True;
# Whether the pipeline is running in dry-run mode

log_level = "info";

if any([arg in sys.argv for arg in ["--rulegraph", "--dag"]]):
    log_level = "notset";
# Set the log level based on the arguments

#log_level = "debug";
# Uncomment to set the log level to debug

log_verbosity = "screen"; # "screen", "file", "both"
log_filename = f"cactus-minigraph.{log_level}.log"; # Log file name if log_verbosity is "file" or "both"
cactuslib.configureLogging(log_filename, log_level.upper(), log_verbosity.upper());
cactuslib_logger = logging.getLogger('cactuslib');
# Setup logging if debugging

# wd = config["working_dir"];
# # if not os.path.exists(wd):
# #     cactuslib_logger.info(f"Creating working directory at {wd}");
# #     os.makedirs(wd);
# cactuslib_logger.info(f"Working directory: {os.getcwd()}");
# cactuslib_logger.info(f"Changing working directory to: {wd}");
# os.chdir(wd);
# Switching to the working directory of the project so paths can be relative

USE_GPU = config["use_gpu"]
# Whether to use GPU or CPU cactus

TMPDIR = config["tmp_dir"];
if not os.path.exists(TMPDIR):
    cactuslib_logger.info(f"Creating temporary directory at {TMPDIR}");
    os.makedirs(TMPDIR);
# A directory with lots of space to use for temporary files generated by the cactus-align command

#JOBDIR = config["job_tmp_dir"];
#JOB_TMP_DIR = os.path.abspath(os.path.join(TMPDIR, JOBDIR));

#cactuslib_logger.info(f"Checking for job tmp dir at {JOB_TMP_DIR}: {os.path.exists(JOB_TMP_DIR)}");

if config["cactus_path"].lower() in ["download", ""]:
    cactus_image_path = cactuslib.downloadCactusImage(USE_GPU);
else:
    cactus_image_path = config["cactus_path"];
    # The path to the cactus image, either downloaded or specified in the config file

    if not os.path.exists(cactus_image_path):
        cactuslib_logger.error(f"Could not find cactus image at {cactus_image_path}");
        sys.exit(1);
    # Check if the cactus image exists

# CACTUS_PATH = f"singularity exec --nv --cleanenv {cactus_image_path}"
# CACTUS_PATH_TMP = f"singularity exec --nv --cleanenv --bind {TMPDIR}:/tmp {cactus_image_path}"

CACTUS_PATH = ["singularity", "exec", "--nv", "--cleanenv", cactus_image_path]
CACTUS_PATH_TMP = ["singularity", "exec", "--nv", "--cleanenv", "--bind", f"{TMPDIR}:/tmp", cactus_image_path]
# The path to the cactus image with and without a tmpdir binding

#############################################################################
# Input files and output paths

INPUT_FILE_ORIG = os.path.abspath(config["input_file"]);
if not os.path.isfile(INPUT_FILE_ORIG):
    cactuslib_logger.error(f"Could not find input file at {INPUT_FILE_ORIG}");
    sys.exit(1);
else:
    cactuslib_logger.info(f"Input file found at {INPUT_FILE_ORIG}");
# The cactus input file used to generate the config file with cactus-prepare

OUTPUT_DIR = os.path.abspath(config["output_dir"]);
OVERWRITE_OUTPUT_DIR = config["overwrite_output_dir"];
# The output directory specified when cactus-prepare was run

INPUT_FILE_COPY = os.path.join(OUTPUT_DIR, os.path.basename(INPUT_FILE_ORIG));
cactuslib_logger.info(f"During rule copy_input, a copy of the input file will be created and modified at {INPUT_FILE_COPY}");
# A copy of the input file must be created and used since cactus-minigraph modifies the input file

CHROMS_DIR = os.path.join(OUTPUT_DIR, "chroms");
# The directory where the split chromosomes are stored
# (generated during split:)

CHROMS_FILE = os.path.join(CHROMS_DIR, "chromfile.txt");
# The file that contains the list of chromosomes and their corresponding sequence files
# (generated during split:)

CHROMS_SEQFILE_DIR = os.path.join(CHROMS_DIR, "seqfiles");
# The directory where the split chromosome sequence files are stored
# (generated during split:)

ALIGN_DIR = os.path.join(OUTPUT_DIR, "chrom-alignments");
# The directory where the aligned chromosomes are stored
# (generated during align:)

FINAL_DIR = os.path.join(OUTPUT_DIR, "final");
# The directory where the final output files are stored
# (generated during join:)

REF_GENOME = config["reference"];
# The reference genome used for alignment

PREFIX = config["prefix"];
# The prefix for the output files

#OUTPUT_HAL = os.path.join(OUTPUT_DIR, config["final_hal"]);
#OUTPUT_MAF = os.path.join(OUTPUT_DIR, config["final_hal"].replace(".hal", ".maf"));

#job_path = os.path.join(OUTPUT_DIR, "jobstore");
# The temporary/job directory specified in cactus-prepare

if log_level == "debug":
    cactuslib_logger.debug("EXITING BEFORE RULES. DEBUG MODE.");
    sys.exit(0);
# Exit before running rules if in debug mode

#############################################################################
# Final rule - rule that depends on final expected output file and initiates all
# the other rules

localrules: all

rule all:
    input:
        final_hal = os.path.join(FINAL_DIR, f"{PREFIX}.full.hal"),
        final_gfa = os.path.join(FINAL_DIR, f"{PREFIX}.gfa.gz"),
        final_vcf = os.path.join(FINAL_DIR, f"{PREFIX}.vcf.gz"),
        final_vcf_index = os.path.join(FINAL_DIR, f"{PREFIX}.vcf.gz.tbi"),
        final_dist = os.path.join(FINAL_DIR, f"{PREFIX}.dist"),
        final_gbz = os.path.join(FINAL_DIR, f"{PREFIX}.gbz"),
        final_min = os.path.join(FINAL_DIR, f"{PREFIX}.min"),
        final_raw_vcf = os.path.join(FINAL_DIR, f"{PREFIX}.raw.vcf.gz"),
        final_raw_vcf_index = os.path.join(FINAL_DIR, f"{PREFIX}.raw.vcf.gz.tbi"),
        final_stats = os.path.join(FINAL_DIR, f"{PREFIX}.stats.tgz")
        #expand(os.path.join(OUTPUT_DIR, "chrom-alignments", "{chrom}.hal"), chrom=gather_chromosomes)
        #getAlignIO(os.path.join(OUTPUT_DIR, "chroms", "chromfile.txt"), "chrom-alignments")["hals"]
        #directory(os.path.join(OUTPUT_DIR, "chroms")),
        #os.path.join(OUTPUT_DIR, "chroms", "chromfile.txt")
## Rule all specifies the final output files expected

# #############################################################################
# # Pipeline rules

rule copy_input:
    input:
        cactus_input = INPUT_FILE_ORIG
    output:
        ready_file = os.path.join(OUTPUT_DIR, "input_ready")
    params:
        cactus_input_copy = INPUT_FILE_COPY,
        fasta = os.path.join(OUTPUT_DIR, f"{PREFIX}.sv.gfa.fa")
    run:
        import os

        print("COPY INPUT")

        # Define the new base directory
        new_base_dir = os.path.dirname(input.cactus_input)

        # Read the input file
        with open(input.cactus_input, "r") as infile:
            lines = infile.readlines()
        
        labels = [];
        outlines = [];

        # Write to the output file
        with open(params.cactus_input_copy, "w") as outfile:
            for line in lines:
                label, path = line.strip().split("\t")
                
                # Determine if the path is a URL or absolute
                if not (path.startswith("http://") or path.startswith("https://") or os.path.isabs(path)):
                    # It's a relative path, update it
                    path = os.path.normpath(os.path.join(new_base_dir, path))
                
                # Write the updated line to the output file
                labels.append(label);
                outlines.append(f"{label}\t{path}\n");

            star_tree = "(" + "".join([ f"{label}:1.0," for label in labels ]) + "_MINIGRAPH_:1);\n";

            outfile.write(star_tree);

            for outline in outlines:
                outfile.write(outline);

            outfile.write(f"_MINIGRAPH_\tfile://{params.fasta}\n");

        # Write the ready file
        with open(output.ready_file, "w") as readyfile:
            readyfile.write("READY\n");
# This is necessary because cactus-minigraph modifies the input file, which means if we used the original, snakemake would think 
# it always needs to re-run the whole pipeline. This rule makes a copy of the input file and updates the paths to be absolute.

####################

rule minigraph:
    input:
        ready_file = os.path.join(OUTPUT_DIR, "input_ready")
    output:
        sv_gfa = os.path.join(OUTPUT_DIR, f"{PREFIX}.sv.gfa"),
    params:
        path = CACTUS_PATH,
        cactus_input = INPUT_FILE_COPY,
        ref_genome = REF_GENOME,
        job_tmp_dir = os.path.join(TMPDIR, "minigraph"), # This is the tmp dir for the host system, which is bound to /tmp in the singularity container
        rule_name = "minigraph"
    log:
        job_log = os.path.join(OUTPUT_DIR, "logs", f"{PREFIX}.minigraph.log")
    resources:
        slurm_partition = config["minigraph_partition"],
        cpus_per_task = config["minigraph_cpu"],
        mem_mb = config["minigraph_mem"],
        runtime = config["minigraph_time"]
    run:
        cmd = params.path + [
            "cactus-minigraph",
            params.job_tmp_dir,
            params.cactus_input,
            output.sv_gfa,
            "--reference",
            params.ref_genome
        ];
        cactuslib.runCommand(cmd, params.job_tmp_dir, log.job_log, params.rule_name);
    # shell:
    #     """
    #     {params.path} cactus-minigraph {params.job_tmp_dir} {input.cactus_input} {output.sv_gfa} --reference {params.ref_genome} --restart
    #     """
    # Keeping shell around now for debugging purposes

####################

rule graphmap:
    input:
        sv_gfa = os.path.join(OUTPUT_DIR, f"{PREFIX}.sv.gfa")
    output:
        paf = os.path.join(OUTPUT_DIR, f"{PREFIX}.paf"),
        fasta = os.path.join(OUTPUT_DIR, f"{PREFIX}.sv.gfa.fa"),
        gaf = os.path.join(OUTPUT_DIR, f"{PREFIX}.gaf.gz"),
        paf_filter_log = os.path.join(OUTPUT_DIR, f"{PREFIX}.paf.filter.log"),
        paf_unfiltered = os.path.join(OUTPUT_DIR, f"{PREFIX}.paf.unfiltered.gz")
    params:
        path = CACTUS_PATH,
        cactus_input = INPUT_FILE_COPY,
        ref_genome = REF_GENOME,
        job_tmp_dir = os.path.join(TMPDIR, "graphmap"), # This is the tmp dir for the host system, which is bound to /tmp in the singularity container
        rule_name = "graphmap"
    log:
        job_log = os.path.join(OUTPUT_DIR, "logs", f"{PREFIX}.graphmap.log")
    resources:
        slurm_partition = config["graphmap_partition"],
        cpus_per_task = config["graphmap_cpu"],
        mem_mb = config["graphmap_mem"],
        runtime = config["graphmap_time"]
    run:
        cmd = params.path + [
            "cactus-graphmap",
            params.job_tmp_dir,
            params.cactus_input,
            input.sv_gfa,
            output.paf,
            "--outputFasta",
            output.fasta,
            "--reference",
            params.ref_genome
        ];
        cactuslib.runCommand(cmd, params.job_tmp_dir, log.job_log, params.rule_name);
    # shell:
    #     """
    #     {params.path} cactus-graphmap {params.job_tmp_dir} {input.cactus_input} {input.sv_gfa} {output.paf} --outputFasta {output.fasta} --reference {params.ref_genome}
    #     """
    # Keeping shell around now for debugging purposes

####################

checkpoint split:
    input:
        sv_gfa = os.path.join(OUTPUT_DIR, f"{PREFIX}.sv.gfa"),
        paf = os.path.join(OUTPUT_DIR, f"{PREFIX}.paf")
    output:
        # chroms_dir = directory(CHROMS_DIR),
        # seq_dir = directory(CHROMS_SEQFILE_DIR),
        chroms_file = CHROMS_FILE,
        contig_sizes = os.path.join(CHROMS_DIR, "contig_sizes.tsv"),
        minigraph_split_log = os.path.join(CHROMS_DIR, "minigraph.split.log")
    params:
        path = CACTUS_PATH,
        cactus_input = INPUT_FILE_COPY,
        ref_genome = REF_GENOME,
        chroms_dir = CHROMS_DIR,
        job_tmp_dir = os.path.join(TMPDIR, "split"), # This is the tmp dir for the host system, which is bound to /tmp in the singularity container
        rule_name = "split"
    log:
        job_log = os.path.join(OUTPUT_DIR, "logs", f"{PREFIX}.split.log")
    resources:
        slurm_partition = config["split_partition"],
        cpus_per_task = config["split_cpu"],
        mem_mb = config["split_mem"],
        runtime = config["split_time"]
    run:
        cmd = params.path + [
            "cactus-graphmap-split",
            params.job_tmp_dir,
            params.cactus_input,
            input.sv_gfa,
            input.paf,
            "--outDir",
            params.chroms_dir,
            "--reference",
            params.ref_genome
        ];
        cactuslib.runCommand(cmd, params.job_tmp_dir, log.job_log, params.rule_name);
    # shell:
    #     """
    #     {params.path} cactus-graphmap-split {params.job_tmp_dir} {input.cactus_input} {input.sv_gfa} {input.paf} --outDir {output.chroms_dir} --reference {params.ref_genome}
    #     """
    # # Keeping shell around now for debugging purposes

####################

rule align:
    input:
        chrom_seqfile = os.path.join(CHROMS_SEQFILE_DIR, "{chrom}.seqfile"),
        chrom_paf = os.path.join(CHROMS_DIR, "{chrom}", "{chrom}.paf")
    output:
        chrom_hal = os.path.join(ALIGN_DIR, "{chrom}.hal"),
        chrom_vg = os.path.join(ALIGN_DIR, "{chrom}.vg")
    params:
        path = CACTUS_PATH,
        ref_genome = REF_GENOME,
        job_tmp_dir = os.path.join(TMPDIR, "align-{chrom}"), # This is the tmp dir for the host system, which is bound to /tmp in the singularity container
        gpu_opt = "--gpu" if USE_GPU else "",
        rule_name = "align"
    log:
        job_log = os.path.join(OUTPUT_DIR, "logs", f"{PREFIX}.align.{{chrom}}.log")
    resources:
        slurm_partition = config["align_partition"],
        cpus_per_task = config["align_cpu"],
        mem_mb = config["align_mem"],
        runtime = config["align_time"],
        slurm_extra = f"'--gres=gpu:{config["align_gpu"]}'" if USE_GPU else ""
    run:

        #job_log_path = os.path.join(OUTPUT_DIR, "logs", f"{PREFIX}.align.{wildcards.chrom}.log")
        #job_tmp_dir = os.path.join(TMPDIR, f"align-{wildcards.chrom}")

        cmd = params.path + [
            "cactus-align",
            params.job_tmp_dir,
            input.chrom_seqfile,
            input.chrom_paf,
            output.chrom_hal,
            "--pangenome",
            "--reference",
            params.ref_genome,
            "--outVG"
        ];

        if params.gpu_opt:
            cmd.append("--gpu");

        cactuslib.runCommand(cmd, params.job_tmp_dir, log.job_log, params.rule_name, wildcards.chrom);
    # shell:
    #     """
    #     {params.path} cactus-align {params.job_tmp_dir} {input.chrom_seqfile} {input.chrom_paf} {output.chrom_hal} --pangenome --reference {params.ref_genome} --outVG {params.gpu_opt}
    #     """
    # Keeping shell around now for debugging purposes

####################

def gatherChromosomes(wildcards):
# This makes sure the chromosomes file is generated 
# from a checkpoint (split) and reads it in for use in the join and align rules

    chroms_file = checkpoints.split.get(**wildcards).output.chroms_file;
    # 'checkpoints.split.get(...)' ensures the file is generated.

    with open(chroms_file) as f:
        chroms = [line.strip().split("\t")[0] for line in f if line.strip()];
    # Read in the chromosomes file

    return chroms;

####################

rule join:
    input:
        chrom_hal = expand(os.path.join(ALIGN_DIR, "{chrom}.hal"), chrom=gatherChromosomes),
        chrom_vg = expand(os.path.join(ALIGN_DIR, "{chrom}.vg"), chrom=gatherChromosomes)
    output:
        final_hal = os.path.join(FINAL_DIR, f"{PREFIX}.full.hal"),
        final_gfa = os.path.join(FINAL_DIR, f"{PREFIX}.gfa.gz"),
        final_vcf = os.path.join(FINAL_DIR, f"{PREFIX}.vcf.gz"),
        final_vcf_index = os.path.join(FINAL_DIR, f"{PREFIX}.vcf.gz.tbi"),
        final_dist = os.path.join(FINAL_DIR, f"{PREFIX}.dist"),
        final_gbz = os.path.join(FINAL_DIR, f"{PREFIX}.gbz"),
        final_min = os.path.join(FINAL_DIR, f"{PREFIX}.min"),
        final_raw_vcf = os.path.join(FINAL_DIR, f"{PREFIX}.raw.vcf.gz"),
        final_raw_vcf_index = os.path.join(FINAL_DIR, f"{PREFIX}.raw.vcf.gz.tbi"),
        final_stats = os.path.join(FINAL_DIR, f"{PREFIX}.stats.tgz")
    params:
        path = CACTUS_PATH,
        ref_genome = REF_GENOME,
        chrom_haldir = ALIGN_DIR,
        join_outdir = FINAL_DIR,
        prefix = PREFIX,
        job_tmp_dir = os.path.join(TMPDIR, "join"), # This is the tmp dir for the host system, which is bound to /tmp in the singularity container
        rule_name = "join"
    log:
        job_log = os.path.join(OUTPUT_DIR, "logs", f"{PREFIX}.join.log")
    resources:
        slurm_partition = config["align_partition"],
        cpus_per_task = config["align_cpu"],
        mem_mb = config["align_mem"],
        runtime = config["align_time"]
    run:
        vg_files = [
            os.path.join(params.chrom_haldir, f) for f in os.listdir(params.chrom_haldir)
            if f.endswith('.vg')
        ]

        hal_files = [
            os.path.join(params.chrom_haldir, f) for f in os.listdir(params.chrom_haldir)
            if f.endswith('.hal')
        ]
        # Need to manually expand the vg and hal files since subprocess.run() won't do it later on

        cmd = params.path + [
            "cactus-graphmap-join",
            params.job_tmp_dir,
            "--vg"
        ] + vg_files + [
            "--hal"
        ] + hal_files + [
            "--outDir",
            params.join_outdir,
            "--outName",
            params.prefix,
            "--reference",
            params.ref_genome,
            "--vcf",
            "--giraffe",
            "clip"
        ];
        cactuslib.runCommand(cmd, params.job_tmp_dir, log.job_log, params.rule_name);
    # shell:
    #     """
    #     {params.path} cactus-graphmap-join {params.job_tmp_dir} --vg {params.chrom_haldir}/*.vg --hal {params.chrom_haldir}/*.hal --outDir {output.join_outdir} --outName {params.prefix} --reference {params.ref_genome} --vcf --giraffe clip
    #     """
    # Keeping shell around now for debugging purposes

#############################################################################